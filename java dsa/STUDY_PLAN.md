
- **Theory**: `01-java-basics/JavaBasics.java`, `02-arrays/ArrayFundamentals.java`
- **Implementation**: Array operations, 2D arrays
- **Algorithms**: Linear search, basic sorting (bubble, selection)

#### Afternoon Session (2 hours):
**LeetCode Problems (10 problems):**
1. Two Sum (1) - Easy
2. Remove Duplicates from Sorted Array (26) - Easy  
3. Remove Element (27) - Easy
4. Search Insert Position (35) - Easy
5. Plus One (66) - Easy
6. Merge Sorted Array (88) - Easy
7. Pascal's Triangle (118) - Easy
8. Best Time to Buy and Sell Stock (121) - Easy
9. Single Number (136) - Easy
10. Majority Element (169) - Easy




- **Theory**: `02-arrays/ArrayAlgorithms.java`, Two Pointer Technique
- **Algorithms**: Binary search, merge sort basics, two pointers
- **Implementation**: Sliding window problems


**LeetCode Problems (12 problems):**
1. Two Sum II - Input array is sorted (167) - Easy
2. Move Zeroes (283) - Easy
3. Remove Duplicates from Sorted Array II (80) - Medium
4. 3Sum (15) - Medium
5. Container With Most Water (11) - Medium
6. Trapping Rain Water (42) - Hard
7. Rotate Array (189) - Medium
8. Find First and Last Position of Element in Sorted Array (34) - Medium
9. Search in Rotated Sorted Array (33) - Medium
10. Maximum Subarray (53) - Medium
11. Product of Array Except Self (238) - Medium
12. Sliding Window Maximum (239) - Hard


- **Theory**: `03-strings/StringFundamentals.java`, `03-strings/StringAlgorithms.java`
- **Algorithms**: KMP, Rabin-Karp, string manipulation
- **Implementation**: StringBuilder usage, character frequency

**LeetCode Problems (12 problems):**
1. Valid Palindrome (125) - Easy
2. Valid Anagram (242) - Easy
3. First Unique Character in a String (387) - Easy
4. Reverse String (344) - Easy
5. Implement strStr() (28) - Easy
6. Longest Common Prefix (14) - Easy
7. Group Anagrams (49) - Medium
8. Longest Substring Without Repeating Characters (3) - Medium
9. Longest Palindromic Substring (5) - Medium
10. String to Integer (atoi) (8) - Medium
11. Regular Expression Matching (10) - Hard
12. Minimum Window Substring (76) - Hard


- **Pattern Practice**: String manipulation, frequency counting
- **HackerRank**: String algorithm problems

---


- **Theory**: `04-linked-lists/SinglyLinkedList.java`
- **Implementation**: All linked list operations from scratch
- **Algorithms**: Reverse, cycle detection, merge operations


**LeetCode Problems (10 problems):**
1. Reverse Linked List (206) - Easy
2. Merge Two Sorted Lists (21) - Easy
3. Remove Duplicates from Sorted List (83) - Easy
4. Linked List Cycle (141) - Easy
5. Remove Nth Node From End of List (19) - Medium
6. Add Two Numbers (2) - Medium
7. Reverse Linked List II (92) - Medium
8. Reorder List (143) - Medium
9. Merge k Sorted Lists (23) - Hard
10. Reverse Nodes in k-Group (25) - Hard


- **Implementation Practice**: Doubly linked list
- **Pattern Recognition**: Fast/slow pointer technique


- **Theory**: `05-stacks-queues/StackImplementation.java`, `05-stacks-queues/QueueImplementation.java`
- **Advanced Structures**: Deque, circular queue, priority queue basics
- **Applications**: Expression evaluation, BFS/DFS preparation


**LeetCode Problems (12 problems):**
1. Valid Parentheses (20) - Easy
2. Implement Queue using Stacks (232) - Easy
3. Implement Stack using Queues (225) - Easy
4. Min Stack (155) - Easy
5. Evaluate Reverse Polish Notation (150) - Medium
6. Basic Calculator (224) - Hard
7. Sliding Window Maximum (239) - Hard
8. Largest Rectangle in Histogram (84) - Hard
9. Trapping Rain Water (42) - Hard (stack approach)
10. Next Greater Element I (496) - Easy
11. Daily Temperatures (739) - Medium
12. Monotonic Stack problems


- **Advanced**: Implement Deque, circular buffer
- **Pattern Practice**: Monotonic stack/queue

---

- **Theory**: `06-hash-tables/HashTableFundamentals.java`
- **Advanced Structures**: LinkedHashMap, LinkedHashSet, TreeMap, TreeSet
- **Implementation**: Custom hash functions, collision handling


**LeetCode Problems (15 problems):**
1. Contains Duplicate (217) - Easy
2. Valid Anagram (242) - Easy
3. Two Sum (1) - Easy
4. Happy Number (202) - Easy
5. Isomorphic Strings (205) - Easy
6. Contains Duplicate II (219) - Easy
7. Group Anagrams (49) - Medium
8. Top K Frequent Elements (347) - Medium
9. 4Sum (18) - Medium
10. Longest Consecutive Sequence (128) - Hard
11. First Missing Positive (41) - Hard
12. LRU Cache (146) - Medium
13. Design HashMap (706) - Easy
14. Find All Anagrams in a String (438) - Medium
15. Subarray Sum Equals K (560) - Medium


- **Advanced Hashing**: Implement LRU cache
- **HackerRank**: Hash table problems



- **Files to study**: `03-strings/StringFundamentals.java`
- **Practice**:
  - String creation and manipulation
  - StringBuilder usage
  - Character operations
- **Goal**: Master string basics and efficiency


- **Files to study**: `03-strings/StringAlgorithms.java`
- **Practice Problems**:
  - Valid Palindrome (Easy)
  - Valid Anagram (Easy)
  - Reverse String (Easy)
  - First Unique Character (Easy)
  - Longest Common Prefix (Easy)
- **Goal**: Solve 15+ string problems


- **Files to study**: `04-linked-lists/SinglyLinkedList.java`
- **Practice**:
  - Implement basic operations (insert, delete, search)
  - Reverse a linked list
  - Detect cycles and find middle element
- **LeetCode Problems**: Reverse Linked List, Merge Two Sorted Lists
- **Goal**: Master pointer manipulation and linked structures

- **Files to study**: `05-stacks-queues/StackImplementation.java`, `05-stacks-queues/QueueImplementation.java`
- **Practice**:
  - Implement both array and linked versions
  - Solve balanced parentheses problems
  - BFS and DFS patterns
- **LeetCode Problems**: Valid Parentheses, Implement Queue using Stacks
- **Goal**: Understand LIFO and FIFO patterns

- **Files to study**: `06-hash-tables/HashTableFundamentals.java`, `07-arraylist-collections/ArrayListAndCollections.java`
- **Practice**:
  - Use HashMap for frequency counting
  - Solve Two Sum variations
  - Master ArrayList operations
- **LeetCode Problems**: Two Sum, Valid Anagram, Contains Duplicate
- **Goal**: Fast lookups and dynamic arrays


- Tree traversals
- BST operations
- Common tree problems


- Graph representation
- DFS and BFS
- Simple graph problems


- Understanding the concept
- Basic DP problems

**LeetCode Problems (5-7 problems):**
- Easy: Binary Tree Inorder Traversal (94), Maximum Depth of Binary Tree (104), Same Tree (100)
- Medium: Binary Tree Level Order Traversal (102), Validate Binary Search Tree (98)

**Topics:**
- Tree terminology and properties
- Binary tree implementation  
- Tree traversals (inorder, preorder, postorder, level-order)
- Binary Search Tree basics
- BST operations (insert, delete, search)


**LeetCode Problems (5-7 problems):**
- Medium: Lowest Common Ancestor (236), Binary Tree Right Side View (199), Path Sum II (113)
- Hard: Binary Tree Maximum Path Sum (124), Serialize and Deserialize Binary Tree (297)

**Topics:**
- Tree problem-solving patterns
- Path sum problems
- Tree construction from traversals
- Balanced trees
- Tree diameter and height problems


- Easy: Kth Largest Element in Stream (703), Last Stone Weight (1046)
- Medium: Top K Frequent Elements (347), Kth Largest Element (215), Find Median from Data Stream (295)

**Topics:**
- Heap properties and implementation
- Min heap vs Max heap
- Heap operations (insert, delete, heapify)
- Priority Queue in Java
- Heap sort algorithm


**LeetCode Problems (5-7 problems):**
- Medium: Merge k Sorted Lists (23), Task Scheduler (621), Reorganize String (767)
- Hard: Sliding Window Maximum (239), Find Median from Data Stream (295)

**Topics:**
- Top K problems pattern
- Merge multiple sorted structures
- Custom comparators
- Sliding window with heaps

**LeetCode Problems (5-7 problems):**
- Easy: Find the Town Judge (997)
- Medium: Number of Islands (200), Clone Graph (133), Course Schedule (207)

**Topics:**
- Graph representation (adjacency list, matrix)
- Graph traversal (BFS, DFS)
- Connected components
- Cycle detection
- Topological sorting


- Medium: Word Ladder (127), Surrounded Regions (130), Pacific Atlantic Water Flow (417)  
- Hard: Word Ladder II (126), Alien Dictionary (269)

**Topics:**
- Shortest path algorithms
- Dijkstra's algorithm
- Union-Find (Disjoint Set)
- Minimum spanning tree concepts


**LeetCode Problems (7-10 problems):**
- Easy: Climbing Stairs (70), House Robber (198)
- Medium: Coin Change (322), Longest Increasing Subsequence (300), Unique Paths (62)
- Hard: Edit Distance (72), Regular Expression Matching (10)

**Topics:**
- DP fundamentals and patterns
- Memoization vs tabulation
- 1D and 2D DP problems
- Common DP patterns (knapsack, LIS, LCS)


**LeetCode Problems (10-15 problems):**
- Mix of all difficulty levels
- Focus on weak areas identified during practice

**Activities:**
- Complete 2-3 mock contests
- Review all data structures and algorithms
- Practice explaining solutions
- Time management strategies
- Final preparation checklist

---

## Problem List for Java DSA Mastery

### Arrays
1. Two Sum (1) - Easy
2. Remove Duplicates from Sorted Array (26) - Easy
3. Remove Element (27) - Easy
4. Search Insert Position (35) - Easy
5. Plus One (66) - Easy
6. Merge Sorted Array (88) - Easy
7. Pascal's Triangle (118) - Easy
8. Best Time to Buy and Sell Stock (121) - Easy
9. Single Number (136) - Easy
10. Majority Element (169) - Easy

### Two Pointers
1. Two Sum II - Input array is sorted (167) - Easy
2. Move Zeroes (283) - Easy
3. Remove Duplicates from Sorted Array II (80) - Medium
4. 3Sum (15) - Medium
5. Container With Most Water (11) - Medium
6. Trapping Rain Water (42) - Hard
7. Rotate Array (189) - Medium
8. Find First and Last Position of Element in Sorted Array (34) - Medium
9. Search in Rotated Sorted Array (33) - Medium
10. Maximum Subarray (53) - Medium
11. Product of Array Except Self (238) - Medium
12. Sliding Window Maximum (239) - Hard

### Strings
1. Valid Palindrome (125) - Easy
2. Valid Anagram (242) - Easy
3. First Unique Character in a String (387) - Easy
4. Reverse String (344) - Easy
5. Implement strStr() (28) - Easy
6. Longest Common Prefix (14) - Easy
7. Group Anagrams (49) - Medium
8. Longest Substring Without Repeating Characters (3) - Medium
9. Longest Palindromic Substring (5) - Medium
10. String to Integer (atoi) (8) - Medium
11. Regular Expression Matching (10) - Hard
12. Minimum Window Substring (76) - Hard

### Linked Lists
1. Reverse Linked List (206) - Easy
2. Merge Two Sorted Lists (21) - Easy
3. Remove Duplicates from Sorted List (83) - Easy
4. Linked List Cycle (141) - Easy
5. Remove Nth Node From End of List (19) - Medium
6. Add Two Numbers (2) - Medium
7. Reverse Linked List II (92) - Medium
8. Reorder List (143) - Medium
9. Merge k Sorted Lists (23) - Hard
10. Reverse Nodes in k-Group (25) - Hard

### Stacks and Queues
1. Valid Parentheses (20) - Easy
2. Implement Queue using Stacks (232) - Easy
3. Implement Stack using Queues (225) - Easy
4. Min Stack (155) - Easy
5. Evaluate Reverse Polish Notation (150) - Medium
6. Basic Calculator (224) - Hard
7. Sliding Window Maximum (239) - Hard
8. Largest Rectangle in Histogram (84) - Hard
9. Trapping Rain Water (42) - Hard (stack approach)
10. Next Greater Element I (496) - Easy
11. Daily Temperatures (739) - Medium
12. Monotonic Stack problems

### Hash Tables
1. Contains Duplicate (217) - Easy
2. Valid Anagram (242) - Easy
3. Two Sum (1) - Easy
4. Happy Number (202) - Easy
5. Isomorphic Strings (205) - Easy
6. Contains Duplicate II (219) - Easy
7. Group Anagrams (49) - Medium
8. Top K Frequent Elements (347) - Medium
9. 4Sum (18) - Medium
10. Longest Consecutive Sequence (128) - Hard
11. First Missing Positive (41) - Hard
12. LRU Cache (146) - Medium
13. Design HashMap (706) - Easy
14. Find All Anagrams in a String (438) - Medium
15. Subarray Sum Equals K (560) - Medium

### Trees
1. Binary Tree Inorder Traversal (94) - Easy
2. Maximum Depth of Binary Tree (104) - Easy
3. Same Tree (100) - Easy
4. Binary Tree Level Order Traversal (102) - Medium
5. Validate Binary Search Tree (98) - Medium
6. Lowest Common Ancestor (236) - Medium
7. Binary Tree Right Side View (199) - Medium
8. Path Sum II (113) - Medium
9. Binary Tree Maximum Path Sum (124) - Hard
10. Serialize and Deserialize Binary Tree (297) - Hard

### Graphs
1. Find the Town Judge (997) - Easy
2. Number of Islands (200) - Medium
3. Clone Graph (133) - Medium
4. Course Schedule (207) - Medium
5. Word Ladder (127) - Medium
6. Surrounded Regions (130) - Medium
7. Pacific Atlantic Water Flow (417) - Medium
8. Word Ladder II (126) - Hard
9. Alien Dictionary (269) - Hard

### Dynamic Programming
1. Climbing Stairs (70) - Easy
2. House Robber (198) - Easy
3. Coin Change (322) - Medium
4. Longest Increasing Subsequence (300) - Medium
5. Unique Paths (62) - Medium
6. Edit Distance (72) - Hard
7. Regular Expression Matching (10) - Hard

## Day 7-8: Trees and Binary Search Trees
**Daily Time: 6-8 hours**

### Day 7: Tree Fundamentals
**LeetCode Problems (5-7 problems):**
- Easy: Binary Tree Inorder Traversal (94), Maximum Depth of Binary Tree (104), Same Tree (100)
- Medium: Binary Tree Level Order Traversal (102), Validate Binary Search Tree (98)

**Topics:**
- Tree terminology and properties
- Binary tree implementation  
- Tree traversals (inorder, preorder, postorder, level-order)
- Binary Search Tree basics
- BST operations (insert, delete, search)



**LeetCode Problems (5-7 problems):**
- Medium: Lowest Common Ancestor (236), Binary Tree Right Side View (199), Path Sum II (113)
- Hard: Binary Tree Maximum Path Sum (124), Serialize and Deserialize Binary Tree (297)

**Topics:**
- Tree problem-solving patterns
- Path sum problems
- Tree construction from traversals
- Balanced trees
- Tree diameter and height problems


**LeetCode Problems (5-7 problems):**
- Easy: Kth Largest Element in Stream (703), Last Stone Weight (1046)
- Medium: Top K Frequent Elements (347), Kth Largest Element (215), Find Median from Data Stream (295)

**Topics:**
- Heap properties and implementation
- Min heap vs Max heap
- Heap operations (insert, delete, heapify)
- Priority Queue in Java
- Heap sort algorithm

- Medium: Merge k Sorted Lists (23), Task Scheduler (621), Reorganize String (767)
- Hard: Sliding Window Maximum (239), Find Median from Data Stream (295)

**Topics:**
- Top K problems pattern
- Merge multiple sorted structures
- Custom comparators
- Sliding window with heaps

 **Graph Fundamentals** 
**LeetCode Problems (5-7 problems):**
- Easy: Find the Town Judge (997)
- Medium: Number of Islands (200), Clone Graph (133), Course Schedule (207)

**Topics:**
- Graph representation (adjacency list, matrix)
- Graph traversal (BFS, DFS)
- Connected components
- Cycle detection
- Topological sorting

**LeetCode Problems (5-7 problems):**
- Medium: Word Ladder (127), Surrounded Regions (130), Pacific Atlantic Water Flow (417)  
- Hard: Word Ladder II (126), Alien Dictionary (269)

**Topics:**
- Shortest path algorithms
- Dijkstra's algorithm
- Union-Find (Disjoint Set)
- Minimum spanning tree concepts




**LeetCode Problems (7-10 problems):**
- Easy: Climbing Stairs (70), House Robber (198)
- Medium: Coin Change (322), Longest Increasing Subsequence (300), Unique Paths (62)
- Hard: Edit Distance (72), Regular Expression Matching (10)

**Topics:**
- DP fundamentals and patterns
- Memoization vs tabulation
- 1D and 2D DP problems
- Common DP patterns (knapsack, LIS, LCS)


**LeetCode Problems (10-15 problems):**
- Mix of all difficulty levels
- Focus on weak areas identified during practice

**Activities:**
- Complete 2-3 mock contests
- Review all data structures and algorithms
- Practice explaining solutions
- Time management strategies
- Final preparation checklist

---

## Problem-Solving Strategy for Competitive Programming

### Universal Problem-Solving Framework:

#### 1. Problem Analysis Phase (2-3 minutes)
```
Read → Understand → Identify Pattern → Plan Approach
```

**Questions to ask yourself:**
- What is the input/output format?
- What are the constraints? (n ≤ 10^5, etc.)
- What's the time limit?
- Have I seen a similar problem before?
- What data structure would be most efficient?

#### 2. Pattern Recognition Guide:

**Array/String Problems:**
- Two Pointers: `sorted array`, `palindrome`, `pair sum`
- Sliding Window: `subarray`, `substring`, `fixed/variable window`
- Prefix Sum: `range sum`, `subarray sum equals k`

**Tree Problems:**
- DFS: `path problems`, `validation`, `construction`  
- BFS: `level order`, `shortest path in tree`, `rightmost nodes`

**Graph Problems:**
- BFS: `shortest path`, `level-by-level processing`
- DFS: `connected components`, `cycle detection`, `path finding`
- Union-Find: `dynamic connectivity`, `MST`, `islands`

**Dynamic Programming:**
- 1D DP: `fibonacci-like`, `house robber`, `climbing stairs`
- 2D DP: `grid paths`, `edit distance`, `longest common subsequence`
- Knapsack: `subset sum`, `coin change`, `partition problems`

### LeetCode Problem-Solving Template:

```java
public class Solution {
    public ReturnType problemName(InputType input) {
        // Step 1: Handle edge cases
        if (input == null || input.length == 0) {
            return defaultValue;
        }
        
        // Step 2: Initialize variables
        // Choose appropriate data structure
        
        // Step 3: Main algorithm logic
        // Apply the identified pattern
        
        // Step 4: Return result
    }
}
```

### Complexity Analysis Framework:
Always analyze in this order:
1. **Time Complexity**: How does runtime scale with input size?
2. **Space Complexity**: How much extra memory is used?
3. **Can we optimize?**: Trade-offs between time and space

### HackerRank Strategy:
- **Read all problems first** (5 minutes)
- **Solve in order of difficulty** (Easy → Medium → Hard)  
- **Implement fast, optimize later**
- **Test with provided examples**
- **Handle edge cases explicitly**

---

## Advanced Problem-Solving Patterns

### Pattern 1: Two Pointers Technique
```java
// Template for sorted array problems
int left = 0, right = array.length - 1;
while (left < right) {
    if (condition_met) {
        // Process and move both pointers
        left++; right--;
    } else if (sum < target) {
        left++; // Move left to increase sum
    } else {
        right--; // Move right to decrease sum
    }
}
```

### Pattern 2: Sliding Window
```java
// Fixed size window
int windowSum = 0;
for (int i = 0; i < k; i++) {
    windowSum += array[i];
}
int maxSum = windowSum;

for (int i = k; i < array.length; i++) {
    windowSum = windowSum - array[i-k] + array[i];
    maxSum = Math.max(maxSum, windowSum);
}
```

### Pattern 3: Binary Search Template
```java
int left = 0, right = array.length - 1;
while (left <= right) {
    int mid = left + (right - left) / 2;
    if (array[mid] == target) {
        return mid;
    } else if (array[mid] < target) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}
return -1; // Not found
```

### Pattern 4: DFS Template
```java
public void dfs(TreeNode node, /* parameters */) {
    // Base case
    if (node == null) return;
    
    // Process current node
    // Do something with node.val
    
    // Recursive calls
    dfs(node.left, /* updated parameters */);
    dfs(node.right, /* updated parameters */);
}
```

### Pattern 5: BFS Template  
```java
Queue<TreeNode> queue = new LinkedList<>();
queue.offer(root);

while (!queue.isEmpty()) {
    int levelSize = queue.size();
    
    for (int i = 0; i < levelSize; i++) {
        TreeNode node = queue.poll();
        // Process current node
        
        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
    }
}
```

---

## Time Management for Contests

### Contest Strategy (2-hour contest):
- **Minutes 0-5**: Read all problems, identify difficulty
- **Minutes 5-45**: Solve 2-3 easy problems  
- **Minutes 45-90**: Tackle 1-2 medium problems
- **Minutes 90-120**: Attempt hard problem or optimize solutions

### Per Problem Time Allocation:
- **Easy (5-15 minutes)**: Quick implementation, basic patterns
- **Medium (20-35 minutes)**: More complex logic, optimization needed
- **Hard (45+ minutes)**: Advanced algorithms, multiple approaches

### When You're Stuck (5-minute rule):
1. Re-read the problem
2. Check constraints again
3. Try a different approach
4. Move to next problem
5. Come back later if time permits

---

## Debugging and Testing Strategy

### Before Submitting:
1. **Trace through examples** manually
2. **Check edge cases**: empty input, single element, maximum constraints
3. **Verify time complexity** meets requirements
4. **Look for off-by-one errors**
5. **Ensure proper variable initialization**

### Common Bug Categories:
- **Array bounds**: index out of range
- **Integer overflow**: use long when needed
- **Null pointer**: check for null inputs
- **Logical errors**: wrong condition in if statements
- **Infinite loops**: verify loop termination

### Testing Checklist:
- [ ] Empty input
- [ ] Single element
- [ ] All same elements  
- [ ] Sorted input
- [ ] Reverse sorted input
- [ ] Maximum constraints
- [ ] Minimum constraints

---


---


## Emergency Shortcuts (If Running Out of Time)

### Must-Know Algorithms (memorize these):
1. Binary Search (iterative version)
2. Two Pointers for sorted arrays
3. DFS and BFS traversals
4. Basic DP (fibonacci, coin change)
5. Merge Sort implementation

### High-Impact Practice:
- **Arrays**: Two Sum, Three Sum, Product of Array Except Self
- **Strings**: Valid Parentheses, Longest Substring Without Repeating
- **Trees**: Inorder Traversal, Maximum Depth, Validate BST
- **Graphs**: Number of Islands, Course Schedule
- **DP**: Climbing Stairs, House Robber, Coin Change

### Last-Minute Tips:
1. **Practice explaining solutions** out loud
2. **Use meaningful variable names**
3. **Add comments for complex logic**
4. **Test with simple examples first**
5. **Don't optimize prematurely**

🎯 **Your goal**: Solve problems correctly and efficiently, not just quickly!



